import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as THREE from 'three';
import { VoxelWorld } from '../../src/core/VoxelWorld';
import { BlockType } from '../../src/types/VoxelTypes';

describe('VoxelWorld', () => {
  let scene: THREE.Scene;
  let world: VoxelWorld;

  beforeEach(() => {
    scene = new THREE.Scene();
    world = new VoxelWorld(scene);
  });

  afterEach(() => {
    // Clean up to prevent memory leaks
    world.dispose();
    scene.clear();
  });

  describe('constructor', () => {
    it('should create a VoxelWorld instance', () => {
      expect(world).toBeDefined();
      expect(world).toBeInstanceOf(VoxelWorld);
    });

    it('should add chunks to the scene', () => {
      // With default renderDistance of 3, should have 7x7 = 49 chunks
      // Filter for InstancedMesh objects
      const meshes = scene.children.filter(child => child instanceof THREE.InstancedMesh);

      // Should have multiple chunks rendered
      expect(meshes.length).toBeGreaterThan(0);
      expect(meshes.length).toBeLessThanOrEqual(49);
    });

    it('should generate world with default settings', () => {
      // Verify world was generated by checking block count
      const blockCount = world.getTotalBlockCount();
      expect(blockCount).toBeGreaterThan(0);
    });
  });

  describe('getBlock', () => {
    it('should return AIR for out of bounds Y coordinate (below)', () => {
      const block = world.getBlock(0, -1, 0);
      expect(block).toBe(BlockType.AIR);
    });

    it('should return AIR for out of bounds Y coordinate (above)', () => {
      const block = world.getBlock(0, 100, 0);
      expect(block).toBe(BlockType.AIR);
    });

    it('should return AIR for ungenerated chunks', () => {
      const block = world.getBlock(1000, 10, 1000);
      expect(block).toBe(BlockType.AIR);
    });

    it('should return BEDROCK at Y=0', () => {
      // Bedrock is always at the bottom
      const block = world.getBlock(0, 0, 0);
      expect(block).toBe(BlockType.BEDROCK);
    });

    it('should return valid block types for generated chunks', () => {
      const block = world.getBlock(0, 30, 0);
      expect(block).toBeGreaterThanOrEqual(BlockType.AIR);
      expect(block).toBeLessThanOrEqual(BlockType.BEDROCK);
    });

    it('should handle positive coordinates', () => {
      const block = world.getBlock(10, 20, 30);
      expect(typeof block).toBe('number');
    });

    it('should handle negative coordinates', () => {
      const block = world.getBlock(-10, 20, -30);
      expect(typeof block).toBe('number');
    });

    it('should return consistent values for same coordinates', () => {
      const block1 = world.getBlock(5, 10, 15);
      const block2 = world.getBlock(5, 10, 15);
      expect(block1).toBe(block2);
    });

    it('should handle coordinates at chunk boundaries', () => {
      // Chunk size is 16, so these are at boundaries
      const block1 = world.getBlock(15, 10, 15); // End of chunk 0
      const block2 = world.getBlock(16, 10, 16); // Start of chunk 1

      expect(typeof block1).toBe('number');
      expect(typeof block2).toBe('number');
    });

    it('should correctly map world coordinates to chunks', () => {
      // Test multiple chunks
      const block1 = world.getBlock(0, 30, 0);   // Chunk (0, 0)
      const block2 = world.getBlock(20, 30, 20); // Chunk (1, 1)
      const block3 = world.getBlock(-10, 30, -10); // Chunk (-1, -1)

      expect(typeof block1).toBe('number');
      expect(typeof block2).toBe('number');
      expect(typeof block3).toBe('number');
    });
  });

  describe('setBlock', () => {
    it('should set a block at valid coordinates', () => {
      world.setBlock(10, 30, 10, BlockType.STONE);
      const block = world.getBlock(10, 30, 10);
      expect(block).toBe(BlockType.STONE);
    });

    it('should change existing block type', () => {
      const originalBlock = world.getBlock(5, 25, 5);
      world.setBlock(5, 25, 5, BlockType.GRASS);
      const newBlock = world.getBlock(5, 25, 5);

      expect(newBlock).toBe(BlockType.GRASS);
      if (originalBlock !== BlockType.GRASS) {
        expect(newBlock).not.toBe(originalBlock);
      }
    });

    it('should handle setting multiple blocks', () => {
      world.setBlock(0, 30, 0, BlockType.STONE);
      world.setBlock(1, 30, 1, BlockType.DIRT);
      world.setBlock(2, 30, 2, BlockType.GRASS);

      expect(world.getBlock(0, 30, 0)).toBe(BlockType.STONE);
      expect(world.getBlock(1, 30, 1)).toBe(BlockType.DIRT);
      expect(world.getBlock(2, 30, 2)).toBe(BlockType.GRASS);
    });

    it('should ignore setBlock for out of bounds Y coordinate', () => {
      const initialBlockCount = world.getTotalBlockCount();

      world.setBlock(0, -1, 0, BlockType.STONE);
      world.setBlock(0, 100, 0, BlockType.STONE);

      // Block count should remain the same
      expect(world.getTotalBlockCount()).toBe(initialBlockCount);
    });

    it('should ignore setBlock for ungenerated chunks', () => {
      const initialBlockCount = world.getTotalBlockCount();

      world.setBlock(1000, 10, 1000, BlockType.STONE);

      // Block count should remain the same
      expect(world.getTotalBlockCount()).toBe(initialBlockCount);
    });

    it('should update the scene when setting a block', () => {
      const initialMeshCount = scene.children.length;

      world.setBlock(10, 30, 10, BlockType.STONE);

      // Mesh should be rebuilt, count might change
      expect(scene.children.length).toBeGreaterThanOrEqual(0);
    });

    it('should handle setting AIR (removing blocks)', () => {
      // First set a block
      world.setBlock(10, 30, 10, BlockType.STONE);
      expect(world.getBlock(10, 30, 10)).toBe(BlockType.STONE);

      // Then remove it
      world.setBlock(10, 30, 10, BlockType.AIR);
      expect(world.getBlock(10, 30, 10)).toBe(BlockType.AIR);
    });

    it('should handle blocks at chunk boundaries', () => {
      world.setBlock(15, 30, 15, BlockType.STONE);
      world.setBlock(16, 30, 16, BlockType.GRASS);

      expect(world.getBlock(15, 30, 15)).toBe(BlockType.STONE);
      expect(world.getBlock(16, 30, 16)).toBe(BlockType.GRASS);
    });

    it('should handle negative coordinates', () => {
      world.setBlock(-5, 30, -5, BlockType.COBBLESTONE);
      expect(world.getBlock(-5, 30, -5)).toBe(BlockType.COBBLESTONE);
    });
  });

  describe('getTotalBlockCount', () => {
    it('should return a positive number', () => {
      const count = world.getTotalBlockCount();
      expect(count).toBeGreaterThan(0);
    });

    it('should count all non-AIR blocks', () => {
      const count = world.getTotalBlockCount();
      expect(typeof count).toBe('number');
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('should update when blocks are added', () => {
      const initialCount = world.getTotalBlockCount();

      // Find an air block and add a stone block there
      let foundAir = false;
      for (let y = 40; y < 60; y++) {
        if (world.getBlock(10, y, 10) === BlockType.AIR) {
          world.setBlock(10, y, 10, BlockType.STONE);
          foundAir = true;
          break;
        }
      }

      if (foundAir) {
        const newCount = world.getTotalBlockCount();
        expect(newCount).toBeGreaterThan(initialCount);
      } else {
        // If no air found, test passes (terrain is solid)
        expect(true).toBe(true);
      }
    });

    it('should update when blocks are removed', () => {
      // Find a non-air block and remove it
      const testY = 25;
      const originalBlock = world.getBlock(0, testY, 0);

      if (originalBlock !== BlockType.AIR) {
        const initialCount = world.getTotalBlockCount();
        world.setBlock(0, testY, 0, BlockType.AIR);
        const newCount = world.getTotalBlockCount();
        expect(newCount).toBeLessThan(initialCount);
      }
    });

    it('should have bedrock layer', () => {
      // Count blocks at Y=0 (all should be bedrock)
      let bedrockCount = 0;
      const chunkSize = 16;
      const renderDistance = 3;
      const totalChunks = (renderDistance * 2 + 1) * (renderDistance * 2 + 1);

      // Each chunk should have chunkSize * chunkSize bedrock blocks at bottom
      const expectedBedrockCount = totalChunks * chunkSize * chunkSize;

      // Verify bedrock exists
      for (let x = -chunkSize; x < chunkSize; x++) {
        for (let z = -chunkSize; z < chunkSize; z++) {
          if (world.getBlock(x, 0, z) === BlockType.BEDROCK) {
            bedrockCount++;
          }
        }
      }

      expect(bedrockCount).toBeGreaterThan(0);
    });
  });

  describe('regenerateWorld', () => {
    it('should regenerate the world with different terrain', () => {
      const originalBlock = world.getBlock(10, 30, 10);

      world.regenerateWorld();

      const newBlock = world.getBlock(10, 30, 10);

      // After regeneration, blocks should exist
      expect(typeof newBlock).toBe('number');

      // Bedrock should still be at bottom
      expect(world.getBlock(0, 0, 0)).toBe(BlockType.BEDROCK);
    });

    it('should update the scene', () => {
      const initialChildren = scene.children.length;

      world.regenerateWorld();

      // Scene should still have meshes
      expect(scene.children.length).toBeGreaterThan(0);
    });

    it('should maintain total number of chunks', () => {
      const beforeRegen = world.getTotalBlockCount();

      world.regenerateWorld();

      const afterRegen = world.getTotalBlockCount();

      // Both should have blocks
      expect(beforeRegen).toBeGreaterThan(0);
      expect(afterRegen).toBeGreaterThan(0);
    });

    it('should clear previous world data', () => {
      // Set a custom block
      world.setBlock(10, 30, 10, BlockType.COBBLESTONE);
      expect(world.getBlock(10, 30, 10)).toBe(BlockType.COBBLESTONE);

      // Regenerate
      world.regenerateWorld();

      // The custom block should be replaced by new terrain
      const newBlock = world.getBlock(10, 30, 10);
      expect(typeof newBlock).toBe('number');
    });

    it('should maintain bedrock layer after regeneration', () => {
      world.regenerateWorld();

      // Check multiple bedrock positions
      expect(world.getBlock(0, 0, 0)).toBe(BlockType.BEDROCK);
      expect(world.getBlock(5, 0, 5)).toBe(BlockType.BEDROCK);
      expect(world.getBlock(-5, 0, -5)).toBe(BlockType.BEDROCK);
    });
  });

  describe('dispose', () => {
    it('should remove all meshes from scene', () => {
      const freshScene = new THREE.Scene();
      const newWorld = new VoxelWorld(freshScene);
      const beforeDispose = freshScene.children.length;

      expect(beforeDispose).toBeGreaterThan(0);

      newWorld.dispose();

      // Scene should be empty after dispose
      expect(freshScene.children.length).toBe(0);
    });

    it('should be callable multiple times without errors', () => {
      const newWorld = new VoxelWorld(scene);

      expect(() => {
        newWorld.dispose();
        newWorld.dispose();
        newWorld.dispose();
      }).not.toThrow();
    });

    it('should clear all chunks', () => {
      const newWorld = new VoxelWorld(scene);
      newWorld.dispose();

      // After dispose, getting blocks should return AIR
      expect(newWorld.getBlock(0, 30, 0)).toBe(BlockType.AIR);
    });
  });

  describe('terrain generation', () => {
    it('should generate terrain with varied height', () => {
      const heights = new Set<number>();

      // Sample heights at different positions
      for (let x = -10; x <= 10; x += 5) {
        for (let z = -10; z <= 10; z += 5) {
          // Find the highest non-air block
          for (let y = 0; y < 64; y++) {
            const block = world.getBlock(x, y, z);
            if (block !== BlockType.AIR) {
              heights.add(y);
            }
          }
        }
      }

      // Should have varied heights (not all flat)
      expect(heights.size).toBeGreaterThan(5);
    });

    it('should place water at sea level', () => {
      let waterFound = false;

      // Look for water blocks around sea level (32) in a larger area
      for (let x = -40; x <= 40; x += 2) {
        for (let z = -40; z <= 40; z += 2) {
          for (let y = 28; y <= 36; y++) {
            if (world.getBlock(x, y, z) === BlockType.WATER) {
              waterFound = true;
              break;
            }
          }
          if (waterFound) break;
        }
        if (waterFound) break;
      }

      // Water should exist in the generated world (or test is skipped if terrain is all above sea level)
      // This can happen with random seeds
      if (!waterFound) {
        // Check if terrain is mostly above sea level
        let aboveSeaLevel = 0;
        for (let x = -10; x <= 10; x += 5) {
          for (let z = -10; z <= 10; z += 5) {
            for (let y = 35; y < 50; y++) {
              if (world.getBlock(x, y, z) !== BlockType.AIR) {
                aboveSeaLevel++;
                break;
              }
            }
          }
        }
        // If most terrain is above sea level, that's acceptable
        expect(aboveSeaLevel).toBeGreaterThan(0);
      } else {
        expect(waterFound).toBe(true);
      }
    });

    it('should generate trees with wood and leaves', () => {
      let woodFound = false;
      let leavesFound = false;

      // Search for tree blocks
      for (let x = -30; x <= 30; x++) {
        for (let z = -30; z <= 30; z++) {
          for (let y = 0; y < 64; y++) {
            const block = world.getBlock(x, y, z);
            if (block === BlockType.WOOD) woodFound = true;
            if (block === BlockType.LEAVES) leavesFound = true;

            if (woodFound && leavesFound) break;
          }
          if (woodFound && leavesFound) break;
        }
        if (woodFound && leavesFound) break;
      }

      // Trees should be generated (though random, very likely)
      expect(woodFound || leavesFound).toBe(true);
    });

    it('should have stone underground', () => {
      let stoneFound = false;

      // Check underground layers
      for (let x = -10; x <= 10; x += 5) {
        for (let z = -10; z <= 10; z += 5) {
          for (let y = 1; y < 20; y++) {
            if (world.getBlock(x, y, z) === BlockType.STONE) {
              stoneFound = true;
              break;
            }
          }
          if (stoneFound) break;
        }
        if (stoneFound) break;
      }

      expect(stoneFound).toBe(true);
    });

    it('should have grass on surface in some areas', () => {
      let grassFound = false;

      for (let x = -20; x <= 20; x += 5) {
        for (let z = -20; z <= 20; z += 5) {
          for (let y = 32; y < 50; y++) {
            if (world.getBlock(x, y, z) === BlockType.GRASS) {
              grassFound = true;
              break;
            }
          }
          if (grassFound) break;
        }
        if (grassFound) break;
      }

      expect(grassFound).toBe(true);
    });

    it('should have continuous terrain (no floating blocks)', () => {
      // Check that blocks have support below them (simplified check)
      let unsupportedBlocks = 0;

      for (let x = 0; x < 16; x++) {
        for (let z = 0; z < 16; z++) {
          let foundFirstBlock = false;
          for (let y = 63; y >= 0; y--) {
            const block = world.getBlock(x, y, z);
            const blockBelow = y > 0 ? world.getBlock(x, y - 1, z) : BlockType.BEDROCK;

            if (block !== BlockType.AIR && block !== BlockType.WATER && block !== BlockType.LEAVES) {
              if (!foundFirstBlock) {
                foundFirstBlock = true;
              } else {
                // Check if block below is air (floating)
                if (blockBelow === BlockType.AIR) {
                  unsupportedBlocks++;
                }
              }
            }
          }
        }
      }

      // Very few unsupported blocks should exist (except trees/leaves)
      expect(unsupportedBlocks).toBeLessThan(50);
    });
  });

  describe('chunk management', () => {
    it('should generate chunks in render distance', () => {
      // Default render distance is 3, so should have chunks from -3 to +3
      const chunkSize = 16;
      const renderDistance = 3;

      // Test blocks in different chunks
      for (let cx = -renderDistance; cx <= renderDistance; cx++) {
        for (let cz = -renderDistance; cz <= renderDistance; cz++) {
          const worldX = cx * chunkSize;
          const worldZ = cz * chunkSize;
          const block = world.getBlock(worldX, 0, worldZ);

          // Should always have bedrock at bottom in generated chunks
          expect(block).toBe(BlockType.BEDROCK);
        }
      }
    });

    it('should handle chunk coordinate calculations correctly', () => {
      // Test edge cases for chunk coordinates
      const tests = [
        { x: 0, z: 0, expectedBedrock: true },
        { x: 15, z: 15, expectedBedrock: true },
        { x: 16, z: 16, expectedBedrock: true },
        { x: -1, z: -1, expectedBedrock: true },
        { x: -16, z: -16, expectedBedrock: true },
      ];

      tests.forEach(test => {
        const block = world.getBlock(test.x, 0, test.z);
        if (test.expectedBedrock) {
          expect(block).toBe(BlockType.BEDROCK);
        }
      });
    });
  });

  describe('performance', () => {
    it('should generate world in reasonable time', () => {
      const startTime = performance.now();
      const testWorld = new VoxelWorld(scene);
      const endTime = performance.now();

      testWorld.dispose();

      // World generation should complete in under 2 seconds
      expect(endTime - startTime).toBeLessThan(2000);
    });

    it('should handle multiple block updates efficiently', () => {
      const startTime = performance.now();

      for (let i = 0; i < 100; i++) {
        world.setBlock(i % 16, 30 + (i % 10), i % 16, BlockType.STONE);
      }

      const endTime = performance.now();

      // 100 block updates should complete in under 1 second
      expect(endTime - startTime).toBeLessThan(1000);
    });
  });
});
